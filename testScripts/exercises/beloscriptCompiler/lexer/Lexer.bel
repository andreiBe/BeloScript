Position = import "../Position.bel"
LexResult = import "LexResult.bel"
TokenType = import "TokenType.bel"
Token = import "Token.bel"

IllegalCharError = import "../errors/IllegalCharError.bel"
keywords = (["and", "or", "not", "if","else","elif",
                       "for", "while","function","return","continue",
                       "break","in","try", "catch","import","export", "class", "enum", "static"])

escapeCharacters = {
    "n": "\n",
    "t": "\t"
}
TokenType.spread()

class Lexer(filename, text) {
    # käsiteltävä teksti
    private final text
    # kohta tekstistä, jota käsitellään
    private pos
    # tiedosto, jota käsittellään
    private fileName
    private curChar
    #sisältää tiedon siitä kuinka syvällä suluissa ollaan. Eli kuinka monta avautuvaa suljetta "(" ollaan löydetty, joille
    #ei olla löydetty vastaavaa sulkevaa suljetta ")"
    private paramDeepness = 0

    Lexer {
        self.pos = Position(-1, 0, -1, self.fileName, self.text);
        self.curChar = 0;
        self.advance();
    }
   private advance() {
        self.pos.advance(self.curChar);
        print("Before " + self.curChar)
        self.curChar = if (self.pos.index < self.text.size()) self.text[self.pos.index] else 0
        print(self.curChar)
        print(0)
    }
    # ainut public metodi, joka palauttaa LexResultin, joka sisältää token listan ja mahdolliset virheet suorituksessa
    public makeTokens() {
        tokens = []
        # Käydään kaikki tiedoston merkit läpi.
        while (self.curChar != 0) { # ei olla käsitelty kaikkia merkkejä
            if (self.curChar == " " or self.curChar == "\t") {
                #välilyönnit ja tabit jätetään huomiotta
                self.advance();
            }
            else if (self.curChar == "\n" or self.curChar == ";") {
                # Sulkujen sisällä olevat välilyönnit jätetään huomiotta
                if (self.paramDeepness == 0) {
                    tokens.push(Token(NEWLINE,self.pos));
                }
                self.advance();
            }
            else if (self.curChar == "{") {
                tokens.push(Token(OPENING_BRACKET,self.pos));
                self.advance();
            }
            else if (self.curChar == "}") {
                tokens.push(Token(CLOSING_BRACKET,self.pos));
                self.advance();
            }
            else if (self.curChar == "[") {
                tokens.push(Token(OPENING_SQUARE,self.pos));
                self.advance();
            }
            else if (self.curChar == "]") {
                tokens.push(Token(CLOSING_SQUARE,self.pos));
                self.advance();
            }
            else if (self.curChar == ":") {
                tokens.push(Token(DOUBLEDOT,self.pos));
               self.advance();
            }
            else if (self.curChar == ".") {
                tokens.push(Token(DOT,self.pos));
               self.advance();
            }
            else if (self.curChar == "#") {
                self.skipComment();
            }
            else if (self.curChar == ",") {
                tokens.push(Token(COMMA,pos));
               self.advance();
            }
            else if (self.curChar == "\"") {
                tokens.push(self.makeString());
            }
            else if (self.curChar == "/") {
                tokens.push(self.makeDivOrEQ());
            }
            else if (self.curChar == "+") {
                tokens.push(self.makePlusOrEQorPlusplus());
            }
            else if (self.curChar == "-") {
                tokens.push(self.makeMinusOrArrowOrMinEQ());
            }
            else if (self.curChar == "*") {
                tokens.push(self.makeMulOrEQ());
            }
            else if (self.curChar == "^") {
                tokens.push(self.makePowOrEQ());
            }
            else if (self.curChar == "%") {
                tokens.push(self.makeRemainderOrEQ());
            }
            else if (self.curChar == "(") {
                self.paramDeepness+=1;
                tokens.push(Token(TokenType.LPAREN,null,self.pos, null));
               self.advance();
            }
            else if (self.curChar == ")") {
                self.paramDeepness-=1;
                tokens.push(Token(TokenType.RPAREN,null,self.pos,null));
               self.advance();
            }
            else if (self.curChar == "!") {
                r = self.makeNotEquals();
                if (r.hasError()) return r;
                tokens.push(r.getTokens().get(0));
            }
            else if (self.curChar == "=") {
                tokens.push(self.makeEquals());
            }
            else if (self.curChar == "<") {
                tokens.push(self.makeLessThan());
            }
            else if (self.curChar == ">") {
                tokens.push(self.makeGreaterThan());
            }
            else if (self.curChar.isDigits()) {
                tokens.push(self.makeNumber());
            }
            else if (self.curChar.isLetters()) {
                print(self.curChar.isLetters())
                tokens.push(self.make_identifier());
            }
            else {
                #Virhe
                start =self.pos.copy();
                ch = self.curChar;
                self.advance();
                return LexResult([], IllegalCharError(start,self.pos, ch + " " + "at file: "+self.fileName));
            }
        }
        tokens.push(Token(EOF,null,self.pos,null)); # EOF = end of file
        return LexResult(tokens, null);
    }
    private make_identifier() {
            bu = StringBuilder();
            pos_start = self.pos.copy();

            while (self.curChar != 0 and (isLetterOrDigit(self.curChar) or self.curChar == "_")) {
                bu.append(self.curChar);
                self.advance();
            }
            str = bu.toString();
            type = if (keywords.contains(str)) KEYWORD else IDENTIFIER;
            return Token(type, str, pos_start, self.pos);
    }
    private makeString() {
            start = self.pos.copy();
            sb = StringBuilder();
            escapeCharacter = false;
            self.advance();
            while (self.curChar != 0 and (self.curChar != "\"" or escapeCharacter)) {
                if (escapeCharacter) {
                    sb.append(escapeCharacters.getOrDefault(self.curChar,self.curChar));
                    escapeCharacter = false;
                } else {
                    if (self.curChar == "\\") {
                        escapeCharacter = true;
                    }
                    else {
                        sb.append(self.curChar);
                    }
                }
                self.advance();
            }
            self.advance();

            return Token(STRING, sb.toString(), start, self.pos);
    }
}
export Lexer