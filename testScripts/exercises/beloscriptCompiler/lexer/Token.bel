TokenType = import "TokenType.bel"
TokenType.spread()

class Token(type, value, start, end) {
    type
    value
    start
    end
    Token {
        if (self.value == null) self.value = ""
        if (self.end == null) self.end = self.start.copy().advance(0)
        self.start = self.start.copy()
        self.end = self.end.copy()
    }

    matches(type,value) {
        return type == self.type and value == self.value
    }

    getType() {
        return self.type
    }

    getValue() {
        return self.value;
    }
    getNumValue() {
        return to_num(self.value)
    }

    getStart() {
        return self.start
    }

    getEnd() {
        return self.end
    }

    typeInList(tokenTypes) {
        for (tokenType in tokenTypes) {
            if (self.type == tokenType) return true;
        }
        return false;
    }
    typeAndValueMatches(pairsOfTokenTypeAndValue) {
        for (token in pairsOfTokenTypeAndValue) {
            if (self.type == token.first() and self.value == token.second()) return true;
        }
        return false;
    }
    static SETTERS = [EQ, PLUSEQ, MINUSEQ, DIVEQ,INTDIVEQ, MULEQ, POWEQ, REMEQ]
    static getMatchingCalculation(type) {
            switch (type) {
                case PLUS:
                case PLUSEQ:
                    return function(a,b) -> a.add(b)
                case MINUS:
                case MINUSEQ:
                    return function(a,b) -> a.substract(b)
                case MUL:
                case MULEQ:
                    return function(a,b) -> a.multiply(b)
                case DIV:
                case DIVEQ:
                    return function(a,b) -> a.divide(b)
                case INTDIV:
                case INTDIVEQ:
                    return function(a,b) -> a.intdiv(b);
                case REMAINDER:
                case REMEQ:
                    return function(a,b) -> a.remainder(b);
                case POW:
                case POWEQ:
                    return function(a,b) -> a.power(b);
                case EE:
                    return function(first, second) -> BeloDouble(first.compare(second) == 0);
                case LTE:
                    return function(first, second) -> BeloDouble(first.compare(second) <= 0);
                case GTE:
                    return function(first, second) -> BeloDouble(first.compare(second) >= 0);
                case LT:
                    return function(first, second) -> BeloDouble(first.compare(second) < 0);
                case GT:
                    return function(first, second) -> BeloDouble(first.compare(second) > 0);
                case NE:
                    return function(first, second) -> BeloDouble(first.compare(second) != 0);
            }
            return null;
        }
}
export Token